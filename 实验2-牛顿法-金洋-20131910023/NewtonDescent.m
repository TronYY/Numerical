n=0;%迭代步数
x=100000000;%初值
e1=10^-3;e2=10^-3;%要求跟的精度
e3=0.00001;%为了防止无休止地细分t而设
e4=10;%为处理初值取得太差的情况而设
N=50;%最多跳跃步数

k=1;
t=1;%下山因子
x(k+1)=x(k)-f(x(k))/df(x(k));

while ~( (abs(x(k+1)-x(k))<e1)  || ( abs(f(x(k+1)))<e2) )%当还没有求出符合条件的解时继续循环
    
    while ( abs(f(x(k+1)))>= abs(f(x(k))) )%当下山条件不满足时进入循环修改下山因子
        
        if (t>=e3)%下山因子仍然可以细分
            t=t/2;%下山因子取半
            x(k+1)=x(k)-t*f(x(k))/df(x(k));%以加权平均值作为新的近似解
        
        else%下山因子不可再细分时，说明初值取得太差
       
            x(k)=x(k+1)+e4;%重新调整此轮初值
            n=n+1;%跳跃次数
            if (n<N)%跳跃次数未超过限制时
                t=1;%初始化下山因子
                x(k+1)=x(k)-t*f(x(k))/df(x(k));
            else 
                %跳跃次数太多，结束程序
                error('Method failed after N iterations.');
            end
            
        end
              
    end
    
    t=1;%下山因子重新置为1;
    k=k+1;
    x(k+1)=x(k)-f(x(k))/df(x(k));%牛顿法得到的下个一个根
    
end
x
x(k+1)
